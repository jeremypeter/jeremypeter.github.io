<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>The Facade Pattern</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>The Facade Pattern</h1>
					<h3></h3>
					<p>
						<small>Brought to you by <a href="http://hakim.se">Jeremy Peter</a> / <a href="http://twitter.com/jeremywpeter">@jeremywpeter</a></small>
					</p>

					<aside class="notes">
						 It's a really simple pattern to understand. So much so that you've probably used it without even knowing it. 
					</aside>
				</section>

				<section>
					<section>
						<h2>So what is it?</h2>
					</section>

					<section>
						<h2>Simple interface that handles complex actions</h2>

						<aside class="notes">
							Doesn't expose the complex inner workings of the code within it such as error checking or logging. It should just do all of that work for you.
						</aside>
					</section>
				</section>

				<section>
					<h2>So let's see an example</h2>

					<aside class="notes">
						I'm just going to use the example on different ways to styling dom elements. 
					</aside>
				</section>

				<section>
					<section>
						<h2>Pros</h2>						
					</section>
					<section>
						<ul>
							<li>Creates convenience functions/methods</li>
							<li class="fragment">Code can be easier to understand and less prone to bugs</li>
							<li class="fragment">Adds a layer of abstraction that shouldn't affect client code</li>
						</ul>

						<aside class="notes">
							 These helper methods are basic abstraction that help each other out. Abstracting away code gives you flexibility because it allows you to reuse the code in multiple areas instead of having to repeatedly write it. And if you do it right, your code shouldn't conflict with outside classes or functions. 
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Cons</h2>						
					</section>
					<section>
						<ul>
							<li>Can get carried away with convenience methods</li>
							<li class="fragment">Possible performance hit</li>
						</ul>

						<aside class="notes">
							One instance is if your pulling in an entire library to only use a couple of their methods. It would probably be better to extract those methods out or just build them yourself to save on file size. So if you take jquery for example, the way they query an element is a lot slower if were to use the dom method getElementById().
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Common use cases</h2>
					</section>

					<section>
						<ul>
							<li>API's</li>
							<li class="fragment">Code refactoring</li>
						</ul>

						<aside class="notes">
							A couple of common use cases where the facade design pattern can be found useful would be in creating api's. If you've ever heard of or used the library called jQuery, then you should know that they use this pattern thoroughly. Along with pretty much all the other javascript libraries out there. If you find yourself dealing with cross browser differences, then you'll want to think about using the facade pattern to create come helper methods that deal with those differences. Another instance that I can think of would be in code refactoring. If you ever find yourself with an overwhelming amount of code contained withing a function, perhaps you want to use the facade pattern and abstract some of the code into their own functions.
						</aside>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				maxScale: 1.8,
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
